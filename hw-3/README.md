## Пользовательские сессии
Представим, что требуется поддерживать пользовательские сессии. Если между событиями интервал становится больше 30 минут, то требуется разорвать сессию и создать новую. Также требуется для будущего анализа собирать продолжительность сессии, количество событий внутри одной сессии и отфильтровывать пустые сессии (представим, что пустые сессии - сессии, где не происходит никаких событий)
Возможный вид событий:
```
uid
type
timestamp
```
Если использовать dataframe, то для вычисления потребуется создать window по uid, затем упорядочить по timestamp и используя lag для timestamp вычислять разницу между значениями строк. Сопоставлять значению столбца "new_session" является ли событие началом новой сессии. Затем использовать sum для получения sid и потом сортировать события по timestamp и группировать по uid и sid. В результате придется создать 2 новых столбца, использовать 2 window, shuffle, sort и аггрегацию sum.


При использовании RDD мы создаем нужное число партиций по user_id, внутри каждой сортируем по timestamp и проходимся итератором для формирования sid. 

### Почему в данной ситуации RDD лучше?
RDD в данной ситуации проходится лишь итератором по всем ивентам. В отличии от dataframe у него не будет overhead'а для планирования стадий, создания плана выполнения. К тому же, ему не требуется создавать промежуточные колонки и записывать что-то в них. Если говорить общими словами, то RDD (лично по-моему мнению) показывает себя лучше в тех задачах, где требуется реализация алгоритма, например как в данном примере, где требуется знать значения предыдущих строк.
